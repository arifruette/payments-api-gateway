# КПО ДЗ 4

## Краткое описание
Система состоит из нескольких сервисов:
- **orders-service** — управление заказами (создание, просмотр, список), инициирует оплату.
- **payments-service** — управление балансом пользователя и обработка оплаты заказов.
- **api-gateway** — единая точка входа для клиентов, проксирует REST-запросы в микросервисы.
- **frontend** — минимальный веб-клиент (отдельный сервис), работает только через API Gateway.
- Инфраструктура: **Kafka + Zookeeper**, **PostgreSQL** для orders и payments.

Ключевая часть архитектуры — асинхронное взаимодействие между orders-service и payments-service через Kafka с паттернами **Outbox/Inbox** для надежной доставки и идемпотентности.

---

## Архитектура и взаимодействие сервисов

### 1) Синхронное взаимодействие (REST через API Gateway)
Клиент (frontend или любой внешний клиент) обращается только к **api-gateway**.

Основные эндпойнты API Gateway:
- **Orders**
  - `POST /api/orders` — создать заказ (ответ 202 Accepted)
  - `GET /api/orders?user_id=...&limit=...&offset=...` — список заказов пользователя
  - `GET /api/orders/{id}` — получить заказ по id
- **Payments**
  - `POST /api/payments/account` — создать аккаунт пользователя
  - `POST /api/payments/topup` — пополнить баланс
  - `GET /api/payments/balance/{userId}` — получить баланс

API Gateway проксирует запросы в соответствующие сервисы, а также прокидывает корреляционные заголовки (например `X-Correlation-Id`) и идентификатор пользователя (например `X-User-Id`, в зависимости от сценария).

---

### 2) Асинхронное взаимодействие через Kafka (основная часть, даёт максимум баллов)

#### Сценарий: создание заказа и оплата

1. **Клиент** вызывает `POST /api/orders` в **api-gateway**.
2. **api-gateway** отправляет запрос в **orders-service**.
3. **orders-service**:
   - сохраняет заказ в БД со статусом `NEW`;
   - формирует событие **PaymentRequested** (запрос на оплату);
   - записывает событие в **Outbox** (в той же транзакции, что и заказ).
4. **OutboxPublisher (orders-service)** периодически читает outbox и публикует события в Kafka, после успешной публикации помечает записи как обработанные/отправленные.
5. **payments-service** получает событие PaymentRequested из Kafka.
6. **payments-service** обрабатывает событие с использованием **Transactional Inbox**:
   - фиксирует факт обработки/состояние обработки события в Inbox;
   - выполняет списание средств (если возможно);
   - формирует событие **PaymentResult** (SUCCEEDED/FAILED);
   - записывает PaymentResult в outbox (в рамках той же транзакции);
   - помечает inbox как PROCESSED, чтобы обеспечить идемпотентность.
7. **OutboxPublisher (payments-service)** публикует PaymentResult в Kafka.
8. **orders-service** получает PaymentResult из Kafka и обновляет статус заказа:
   - SUCCEEDED → `FINISHED`
   - FAILED → `CANCELLED`
9. Клиент видит изменение статуса через `GET /api/orders` или `GET /api/orders/{id}`.

Таким образом:
- REST используется для команд/запросов от клиента.
- Kafka используется для событий и межсервисной асинхронной бизнес-логики (оплата).

---

## Особенности Kafka и надежность доставки

### Kafka в системе
Kafka используется как транспорт событий между независимыми сервисами:
- **orders-service → payments-service**: `PaymentRequested`
- **payments-service → orders-service**: `PaymentResult`

Kafka обеспечивает:
- буферизацию,
- повторную доставку сообщений,
- масштабирование потребителей,
- разрыв по времени между сервисами (orders не ждёт payments синхронно).

### Outbox Pattern (на стороне продюсера)
Проблема: если сервис сначала запишет данные в БД, а потом отправит сообщение в Kafka, возможна рассинхронизация (краш между действиями).
Решение: **Outbox** хранит событие в БД вместе с бизнес-изменением в одной транзакции, а отдельный паблишер гарантированно (с ретраями) публикует события позже.

Преимущества:
- событие не “теряется” при сбое,
- публикация отделена от транзакции доменной логики,
- система ведет себя устойчиво при временной недоступности Kafka.

### Inbox Pattern (на стороне консьюмера)
Проблема: Kafka может доставить одно и то же сообщение повторно (at-least-once).
Решение: **Inbox** сохраняет состояние обработки события, обеспечивая идемпотентность.

В payments-service обработка событий построена так, чтобы:
- повторное сообщение не приводило к повторному списанию денег;
- сбой “посередине” обработки не ломал систему — при повторной доставке обработка корректно завершается.

Итог: достигается effectively-once на уровне бизнес-операции (списание средств по заказу выполняется максимум один раз).

---

## Стек технологий

### Backend
- Kotlin
- Ktor (HTTP-сервер, маршрутизация, плагины)
- Kotlinx Serialization (JSON)
- PostgreSQL (отдельная БД на сервис orders и payments)
- Exposed (SQL-ORM/DSL)
- Apache Kafka (events)
- Docker / Docker Compose

### Frontend
- React + TypeScript
- Vite (сборка)
- Nginx (раздача SPA и прокси `/api/*` в API Gateway)
- Docker

---

## Запуск проекта

### Требования
- Docker
- Docker Compose

### Запуск
Из корня репозитория:

```bash
docker compose up --build
```

Поднимутся:

* zookeeper
* kafka
* order-postgres
* payments-postgres
* order-service
* payments-service
* api-gateway
* frontend

---

### Адреса

* Frontend: `http://localhost:3000`
* API Gateway: `http://localhost:8080`
* Swagger: `http://localhost:8080/` (редирект) либо `http://localhost:8080/swagger`